<!DOCTYPE html><html lang="en"><head><title>example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/iron-router/DOCS</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content="../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../"><meta name="groc-document-path" content="example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/iron-router/DOCS"><meta name="groc-project-path" content="example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/iron-router/DOCS.md"><meta name="groc-github-url" content="https://github.com/LumaPictures/module-layout"><link rel="stylesheet" type="text/css" media="all" href="../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../assets/style.css"><script type="text/javascript" src="../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../../assets/behavior.js"></script><body><div id="meta"><div class="file-path"><a href="https://github.com/LumaPictures/module-layout/blob/master/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/iron-router/DOCS.md">example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/module-layout/example/packages/iron-router/DOCS.md</a></div></div><div id="document"><div class="segment"><div class="comments "><div class="wrapper"><h1 id="iron-router">Iron Router</h1>

<p>A client and server side router designed specifically for Meteor.</p>

<p><strong>Table of Contents</strong></p>

<ul>
<li><a href="#key-concepts">Key Concepts</a>
<ul><li><a href="#named-routes">Named Routes</a></li>
<li><a href="#route-options">Route Options</a></li>
<li><a href="#route-paths-and-parameters">Route Paths and Parameters</a></li>
<li><a href="#dynamic-path-segments">Dynamic Path Segments</a></li>
<li><a href="#query-strings-and-hash-segments">Query Strings and Hash Segments</a></li></ul></li>
<li><a href="#client-side-routing">Client Side Routing</a>
<ul><li><a href="#rendering-the-router">Rendering the Router</a></li>
<li><a href="#path-functions-and-helpers">Path Functions and Helpers</a></li>
<li><a href="#changing-routes-programmatically">Changing routes programmatically</a></li>
<li><a href="#rendering-templates">Rendering Templates</a></li>
<li><a href="#using-a-layout-with-yields">Using a Layout with Yields</a></li>
<li><a href="#data">Data</a></li>
<li><a href="#waiting-on-subscriptions-waiton">Waiting on Subscriptions (waitOn)</a></li>
<li><a href="#waiting-on-subscriptions-wait">Waiting on Subscriptions (wait)</a></li>
<li><a href="#using-a-custom-action-function">Using a Custom Action Function</a></li>
<li><a href="#using-hooks">Using hooks</a></li>
<li><a href="#custom-rendering">Custom Rendering</a></li>
<li><a href="#before-and-after-hooks">Before and After Hooks</a></li>
<li><a href="#unload-hook">Unload Hook</a></li>
<li><a href="#global-router-configuration">Global Router Configuration</a></li></ul></li>
<li><a href="#server-side-routing">Server Side Routing</a></li>
<li><a href="#route-controllers">Route Controllers</a></li>
<li><a href="#examples">Examples</a>
<ul><li><a href="#parsing-url-parameters-oauth-example">Parsing Url Parameters (OAuth Example)</a></li></ul></li>
</ul>

<h2 id="key-concepts">Key Concepts</h2>

<p>Once you add the iron-router package the global <code>Router</code> object is available on
the client and on the server. So you can create your routes and configure the
router outside of your <code>Meteor.isClient</code> and <code>Meteor.isServer</code> blocks. Or, if
you are only going to be using client side routes, it's okay to put the routing
code in your <code>client/</code> folder.</p>

<h3 id="named-routes">Named Routes</h3>

<p>You can declare a named route like this:</p>

<pre><code class="javascript">Router.map(function () {
  this.route('home');
});
</code></pre>

<p>This creates a route with the name "home". The route is named so that you can
quickly get the route by name like this: <code>Router.routes['home']</code>. </p>

<p>By default, routes are created as client routes. This means, the route will only
be run on the client, and not the server. When you click a link that maps to a
client side route, the route will be completely run in the browser without
making a trip to the server. If you click a link that maps to a server route,
the browser will make a server request and the server side router will handle
the link. More information on server side routes is provided below.</p>

<h3 id="route-options">Route Options</h3>

<p>You'll typically provide options to your route. At the very least, you'll tell
the route what <code>path</code> it should match. You provide options to the route by
passing an object as the second parameter to <code>this.route</code> like this:</p>

<pre><code class="javascript">Router.map(function () {
  this.route('home', {
    /* options will go here */
  });
});
</code></pre>

<h3 id="route-paths-and-parameters">Route Paths and Parameters</h3>

<p>The first option you will almost always provide to the route is a <code>path</code>. By
default, the route will use its own name for the path. For example given the
following route:</p>

<pre><code class="javascript">Router.map(function () {
  this.route('home');
});
</code></pre>

<p>The route will map to the path <code>/home</code>. But you'll likely want to provide a
custom path. You can provide a custom path like this:</p>

<pre><code class="javascript">Router.map(function () {
  this.route('home', {
    path: '/' // match the root path
  });
});
</code></pre>

<p>When the url changes, the Router looks for the first Route that matches the
given url path. In this example, when the application first loads, the url will
be: <code>http://localhost:3000/</code> and the <code>home</code> route will match this path.</p>

<h3 id="dynamic-path-segments">Dynamic Path Segments</h3>

<p>Paths get compiled into a regular expression and can support dynamic segments.
You can even use a regular expression as your path value. The values of these
params are made available inside of any route functions using
<code>this.params</code>. You'll see examples of different route functions below. But to
get us started, here are a few examples of dynamic paths:</p>

<pre><code class="javascript">Router.map(function () {
  // No Parameters
  this.route('posts', {
    // matches: '/posts'
    // redundant since the name of the route is posts
    path: '/posts' 
  }); 

  // One Required Parameter
  this.route('postShow', {
    // matches: '/posts/1'
    path: '/posts/:_id' 
  });

  // Multiple Parameters
  this.route('twoSegments', {
    // matches: '/posts/1/2'
    // matches: '/posts/3/4'
    path: '/posts/:paramOne/:paramTwo'
  });

  // Optional Parameters
  this.route('optional', {
    // matches: '/posts/1'
    // matches: '/posts/1/2'
    path: '/posts/:paramOne/:optionalParam?'
  });

  // Anonymous Parameter Globbing 
  this.route('globbing', {
    // matches: '/posts/some/arbitrary/path'
    // matches: '/posts/5'
    // route globs are available
    path: '/posts/*'
  });

  // Named Parameter Globbing
  this.route('namedGlobbing', {
    // matches: '/posts/some/arbitrary/path'
    // matches: '/posts/5'
    // stores result in this.params.file
    path: '/posts/:file(*)'
  });

  // Regular Expressions
  this.route('regularExpressions', {
    // matches: '/commits/123..456'
    // matches: '/commits/789..101112'
    path: /^\/commits\/(\d+)\.\.(\d+)/
  });
});
</code></pre>

<h3 id="query-strings-and-hash-segments">Query Strings and Hash Segments</h3>

<p>Query strings and hashes aren't used to match routes. But they are made
available as properties of <code>this.params</code> inside of your route functions. We
haven't talked about the various route functions yet, but here is an example:</p>

<pre><code class="javascript">Router.map(function () {
  this.route('postShow', {
    path: '/posts/:_id',
    data: function () {
      // the data function is an example where this.params is available

      // we can access params using this.params
      // see the below paths that would match this route
      var params = this.params;

      // query params are added as normal properties to this.params.
      // given a browser path of: '/posts/5?sort_by=created_at
      // this.params.sort_by =&gt; 'created_at'

      // the hash fragment is available on the hash property
      // given a browser path of: '/posts/5?sort_by=created_at#someAnchorTag
      // this.params.hash =&gt; 'someAnchorTag'
    }
  });
});
</code></pre>

<h2 id="client-side-routing">Client Side Routing</h2>

<h3 id="rendering-the-router">Rendering the Router</h3>

<p>By default, the Router is rendered (appended) automatically to the document body
when the DOM is ready. You can override this behavior and render the Router
whenever you'd like by setting a configuration option and using a Handlebars
helper like this:</p>

<pre><code class="javascript">Router.configure({
  autoRender: false
});
</code></pre>

<pre><code class="html">&lt;body&gt;
  &lt;div&gt;
    Some static content goes here
  &lt;/div&gt;

  &lt;div&gt;
    {{renderRouter}}
  &lt;/div&gt;
&lt;/body&gt;
</code></pre>

<h3 id="path-functions-and-helpers">Path Functions and Helpers</h3>

<p>Once your application becomes large enough, it becomes a pain to hard code urls
everywhere. If you end up changing your route path a little, you need to find
all of the href tags in your application and change those as well. It's much
better if we can call a function to return a URL given a parameters object.
There are a few Handlebars helpers you can use directly in your HTML. You can
also call the <code>path</code> and <code>url</code> methods on a route itself. </p>

<p>Let's say we have a route named "postShow" defined like this:</p>

<pre><code class="javascript">Router.map(function () {
  this.route('postShow', {
    path: '/posts/:_id'
  });
});
</code></pre>

<p>You can call the Route's path function to get a path for a given parameter
object. For example:</p>

<pre><code class="javascript">Router.routes['postShow'].path({_id: 1}) =&gt; '/posts/1'
</code></pre>

<p>You can pass query params and a hash value as an option like this:</p>

<pre><code class="javascript">Router.routes['postShow'].path({_id: 1}, {
  query: 'sort_by=created_at',
  hash: 'someAnchorTag'
});
</code></pre>

<p>The query option can also be a regular JavaScript object. It will automatically
be turned into a query string. The above example would also work here:</p>

<pre><code class="javascript">Router.routes['postShow'].path({_id: 1}, {
  query: {
    sort_by: 'created_at'
  },

  hash: 'someAnchorTag'
});
</code></pre>

<p>You can get paths and urls for named routes directly in your html using a global
Handlebars helper. The Handlebars helper uses the current data context as the
first parameter to the <code>path</code> function shown above.</p>

<pre><code class="html">&lt;!-- given a context of {_id: 1} this will render '/posts/1' --&gt;
&lt;a href="{{pathFor 'postShow'}}"&gt;Post Show&lt;/a&gt;
</code></pre>

<p>You can change the data context before using the pathFor helper using the
Handlebars <code>{{#with ...}}</code> helper like this:</p>

<pre><code class="html">{{#with someOtherPost}}
  &lt;!-- someOtherPost now sets the data context --&gt;
  &lt;!-- so say someOtherPost = { _id: 5 } then this renders '/posts/5' --&gt;
  &lt;a href="{{pathFor 'postShow'}}"&gt;Post Show&lt;/a&gt;
{{/with}}
</code></pre>

<p>You can pass query params using the Handlebars helper like
this:</p>

<pre><code class="html">&lt;!-- given a context of {_id: 1} this will render '/posts/1?sort_by=created_at' --&gt;
&lt;a href="{{pathFor 'postShow' sort_by=created_at}}"&gt;Post Show&lt;/a&gt;
</code></pre>

<p>And you can pass a hash value using the Handlbars helper like this:</p>

<pre><code class="html">&lt;!-- given a context of {_id: 1} this will render '/posts/1?sort_by=created_at#someAnchorTag' --&gt;
&lt;a href="{{pathFor 'postShow' sort_by=created_at hash=someAnchorTag}}"&gt;Post Show&lt;/a&gt;
</code></pre>

<h3 id="changing-routes-programmatically">Changing routes programmatically</h3>

<p>Sometimes you'll need to change the route without the user clicking a link. For this you can use <code>Router.go</code>:</p>

<pre><code class="javascript">// you can pass a fully formed URL path in
Router.go('/posts/7');

// but more likely, you'll want to use a route name and pass in arguments,
// as you would in `pathFor`
Router.go('postShow', {_id: 7});
</code></pre>

<p>The current route is returned by <code>Router.current()</code>. It can be <code>null</code> (just like <code>Meteor.user()</code> can be null) so it's best to guard when working with reactive return values. For example, to find the current path:</p>

<pre><code class="javascript">var current = Router.current();
return current &amp;&amp; current.path;
</code></pre>

<h3 id="rendering-templates">Rendering Templates</h3>

<p>The default action for a route is to render a template. You can specify a
template as an option to the route. If you don't provide a template, the route
will assume the template name is the same as the route name. For example:</p>

<pre><code class="javascript">Router.map(function () {
  this.route('home', {
    path: '/'
  });
});
</code></pre>

<p>When you navigate to 'http://localhost:3000/' the above route will automatically
render the template named <code>home</code>.</p>

<p>You can change the template that is automatically rendered by providing a
template option.</p>

<pre><code class="javascript">Router.map(function () {
  this.route('home', {
    path: '/',
    template: 'myHomeTemplate'
  });
});
</code></pre>

<p>The above example will map the <code>http://localhost:3000/</code> url (the <code>/</code> path) and
automatically render the template named <code>myHomeTemplate</code>.</p>

<h3 id="using-a-layout-with-yields">Using a Layout with Yields</h3>

<p>Often times it's useful to have a layout template for a route. Then your route
template renders into the layout. You can actually render multiple templates
into the layout. You can specify a layout template by providing the
<code>layoutTemplate</code> option to your route.</p>

<pre><code class="javascript">Router.map(function () {
  this.route('home', {
    path: '/',
    template: 'myHomeTemplate',
    layoutTemplate: 'layout'
  });
});
</code></pre>

<p>The layout template must declare where it wants various child templates to
render. You can do this by using the <code>{{&gt; yield}}</code> helper. A basic layout would
look like this:</p>

<pre><code class="html">&lt;template name="layout"&gt;
  &lt;div&gt;
    {{&gt; yield}}
  &lt;/div&gt;
&lt;/template&gt;
</code></pre>

<p>But you can also specify regions. This allows you to render templates
into any number of regions in the layout. For example:</p>

<pre><code class="html">&lt;template name="layout"&gt;
  &lt;aside&gt;
    {{&gt; yield region='aside'}}
  &lt;/aside&gt;

  &lt;div&gt;
    {{&gt; yield}}
  &lt;/div&gt;

  &lt;footer&gt;
    {{&gt; yield region='footer'}}
  &lt;/footer&gt;
&lt;/template&gt;
</code></pre>

<p>You can specify which templates to render into the region using the
<code>yieldTemplates</code> option of your route. For example:</p>

<pre><code class="javascript">Router.map(function () {
  this.route('home', {
    path: '/',
    template: 'myHomeTemplate',
    layoutTemplate: 'layout',
    yieldTemplates: {
      'myAsideTemplate': {to: 'aside'},
      'myFooter': {to: 'footer'}
    }
  });
});
</code></pre>

<p>The above example will render the template named <code>myAsideTemplate</code> to the region
named <code>aside</code> and the template named <code>myFooter</code> to the region named <code>footer</code>. The
main template <code>myHomeTemplate</code> specified by the <code>template</code> option will be
rendered into the <strong>main</strong> region. This is the region without a name
in the center that looks like this: <code>{{&gt; yield}}</code>.</p>

<h3 id="data">Data</h3>

<p>You can provide a data context for the current route by providing a <code>data</code>
option to your route. The <code>data</code> value can either be an object or a function
that gets evaluated later (when your route is run). For example:</p>

<pre><code class="javascript">Router.map(function () {
  this.route('home', {
    path: '/',
    template: 'myHomeTemplate',
    layoutTemplate: 'layout',
    yieldTemplates: {
      'myAsideTemplate': {to: 'aside'},
      'myFooter': {to: 'footer'}
    },

    data: {
      title: 'Some Title',
      description: 'Some Description'
    }
  });
});
</code></pre>

<p>Given the above data context, our templates could use the data context like
this:</p>

<pre><code class="html">&lt;template name="myHomeTemplate"&gt;
  {{title}} - {{description}}
&lt;/template&gt;
</code></pre>

<p>The data property can also be a function which is evaluated when the route is
actually run.</p>

<pre><code class="javascript">Router.map(function () {
  this.route('home', {
    path: '/',
    template: 'myHomeTemplate',
    layoutTemplate: 'layout',
    yieldTemplates: {
      'myAsideTemplate': {to: 'aside'},
      'myFooter': {to: 'footer'}
    },

    data: function () {
      // this.params is available inside the data function
      var params = this.params;

      return {
        title: 'Some Title',
        description: 'Some Description'
      }
    }
  });
});
</code></pre>

<p>You can set the global data context of the Router by calling the <code>setData</code>
function of the Router or a RouteController. The data context only invalidates
computations if the data has actually changed from the last time it was set.</p>

<p>You can access the current data context using the <code>getData</code> function inside of
any of your route functions (or RouteController functions). For example:</p>

<pre><code class="javascript">Router.map(function () {
  this.route('post', {
    path: '/posts/:slug',

    waitOn: function () {  // wait for the subscription to be ready; see below
      return Meteor.subscribe('posts');
    },

    data: function () {
      return Posts.findOne({slug: this.params.slug});
    },

    before: function () {
      var post = this.getData();
    }
  });
});
</code></pre>

<p>If your data value or function returns null or undefined, the Router can
automatically render a not found template. This is useful if you want to render
a not found template for data that doesn't exist. The only thing you need to do
is provide a <code>notFoundTemplate</code> option to your route.</p>

<pre><code class="javascript">Router.map(function () {
  this.route('home', {
    path: '/',
    template: 'myHomeTemplate',
    layoutTemplate: 'layout',
    yieldTemplates: {
      'myAsideTemplate': {to: 'aside'},
      'myFooter': {to: 'footer'}
    },

    // render notFound template when data is null or undefined
    notFoundTemplate: 'notFound', 
    data: function () {

      // return Posts.findOne({_id: this.params._id});
      // if the post isn't found then render the notFound template

      // if data function returns null then notFound template is rendered.
      return null;
    }
  });
});
</code></pre>

<p>If you provide a global <code>notFoundTemplate</code>, it will get rendered automatically if
a user visits an un-matched path, assuming it's not already handled on the server-side:</p>

<pre><code class="javascript">// given a browser url of: http://localhost:3000/boguspath

Router.configure({
  notFoundTemplate: 'notFound' // this will render
});
</code></pre>

<h3 id="waitingonsubscriptionswaiton">Waiting on Subscriptions (<code>waitOn</code>)</h3>

<p>Sometimes it's useful to wait until you have data before rendering a page. For
example, let's say you want to show a not found template if the user navigates
to a good url (say, /posts/5) but there is no post with an id of 5. You can't
make this determination until the data from the server has been sent.</p>

<p>To solve this problem, you can <strong>wait</strong> on a subscription, or anything with a
reactive <code>ready()</code> method. To do this, you can provide a <code>waitOn</code> option to your
route like this:</p>

<pre><code class="javascript">Router.map(function () {
  this.route('postShow', {
    path: '/posts/:_id',

    waitOn: function () {
      return Meteor.subscribe('posts');
    }
  });
});
</code></pre>

<p>The <code>waitOn</code> function can return any object that has a <code>ready</code> method. It can
also return an array of these objects if you'd like to wait on multiple
subscriptions.</p>

<pre><code class="javascript">Router.map(function () {
  this.route('postShow', {
    path: '/posts/:slug',

    waitOn: function () {
      // NOTE: this.params is available inside the waitOn function.
      var slug = this.params.slug;
      return [Meteor.subscribe('posts'), Meteor.subscribe('comments', slug)];
    }
  });
});
</code></pre>

<p>When your route is run, it will wait on any subscriptions you've provided in
your <code>waitOn</code> function. If you've provided a <code>loadingTemplate</code>, the default action 
will be to render that template.</p>

<p>While waiting, you can check if your subscriptions are ready in your <code>before</code> hooks, 
<code>action</code> method, and <code>after</code> hooks, by checking <code>this.ready()</code>. </p>

<p>Under the hood, the waitOn function calls the <code>wait(handles, onReady,
onWaiting)</code> method of a RouteController (more on RouteControllers below). If you
need to customize this behavior you can skip providing a <code>waitOn</code> property and
just use the <code>wait</code> method directly in a custom action function or a before
hook.</p>

<p>You can also wait for certain subscriptions on a global level, by passing a <code>waitOn</code>
function in the <code>Router.configure()</code> call:</p>

<pre><code class="js">Router.configure({
  waitOn: function () {
    return Meteor.subscribe('recordSetThatYouNeedNoMatterWhat');
  }
});
</code></pre>

<h3 id="waitingonsubscriptionswait">Waiting on Subscriptions (<code>wait()</code>)</h3>

<pre><code class="js">Router.map(function () {
  this.route('postShow', {
    path: '/posts/:_id',
    before: function() {
      // wait on post
      this.subscribe('post', this.params._id).wait(); // wait

      // don't wait on posts
      this.subscribe('posts');
    }
  });
});
</code></pre>

<p>Calling <code>wait</code> on a subscription handle doesn't actually block anything. It just
adds the subscription handle to a list of handles we are reactively waiting on.
When all of these handles are ready <code>this.ready()</code> on the RouteController will
be true.</p>

<pre><code class="js">Router.map(function () {
  this.route('postShow', {
    path: '/posts/:_id',

    // this is equivalent to 
    // waitOn: function() { 
    //   return Meteor.subscribe('posts', this.params.:id); }
    // }

    before: function() {
      this.subscribe('posts', this.params._id).wait();
    }
  });
});
</code></pre>

<h3 id="using-a-custom-action-function">Using a Custom Action Function</h3>

<p>So far, we haven't had to write much code to get our routes to work. We've just
provided configuration options to the route. Under the hood, when a route is
run, a RouteController gets created and an <strong>action</strong> method gets called on that
RouteController. On the client, the default action function just renders the
main template and then all of the yield templates. We can provide our own
action function like this:</p>

<pre><code class="javascript">Router.map(function () {
  this.route('postShow', {
    path: '/posts/:_id',

    action: function () {
      // this =&gt; instance of RouteController
      // access to:
      //  this.params
      //  this.wait
      //  this.render
      //  this.stop
      //  this.redirect
    }
  });
});
</code></pre>

<h3 id="using-hooks">Using hooks</h3>

<p>There are four types of hooks that a route provides. All can be added at the global level, in a route definition, or defined for a controller.</p>

<ul>
<li><code>before</code> - runs before the action function (possibly many times if reactivity is involved).</li>
<li><code>after</code> - runs after the action function (also reactively)</li>
<li><code>load</code> - runs <em>just once</em> when the route is first loaded. NOTE that this doesn't run again if your page reloads via hot-code-reload, so make sure any variables you set will persist over HCR (for example Session variables).</li>
<li><code>unload</code> - runs <em>just once</em> when you leave the route for a new route.</li>
</ul>

<p>You can also define global hooks which apply to a set of named routes:</p>

<pre><code class="js">// this hook will run on almost all routes
Router.before(mustBeSignedIn, {except: ['login', 'signup', 'forgotPassword']});

// this hook will only run on certain routes
Router.before(mustBeAdmin, {only: ['adminDashboard', 'adminUsers', 'adminUsersEdit']});
</code></pre>

<h3 id="custom-rendering">Custom Rendering</h3>

<p>You can render manually by calling the <code>render</code> function. There are three ways
to call the render method:</p>

<ol>
<li><code>this.render()</code>: Render all of the templates for the Route or
 RouteController. This renders the main template into the main yield region,
 and all of the yieldTemplates into their associated <code>{{&gt; yield region='name'}}</code>
 regions.</li>
<li><code>this.render('templateName')</code>: Render the template named 'templateName'
 into the main yield <code>{{&gt; yield}}</code>.</li>
<li><code>this.render('templateName', {to: 'region'})</code>: Render the template named
 'templateName' into the region named 'region' <code>{{&gt; yield region='region'}}</code>. </li>
</ol>

<p><em>Note: layouts are at the route level, not the template level and you have one
layout per route or a globally defined layout.</em></p>

<h3 id="before-and-after-hooks">Before and After Hooks</h3>

<p>Sometimes you want to execute some code <em>before</em> or <em>after</em> your action function
is called. This is particularly useful for things like showing a login page
anytime a user is not logged in. You can declare before and after hooks by
providing <code>before</code> and <code>after</code> options to the route. The value can be a function
or an array of functions which will be executed in the order they are defined.</p>

<pre><code class="javascript">Router.map(function () {
  this.route('postShow', {
    path: '/posts/:_id',

    before: function () {
      if (!Meteor.user()) {
        // render the login template but keep the url in the browser the same
        this.render('login');

        // stop the rest of the before hooks and the action function 
        this.stop();
      }
    },

    action: function () {
      // render the main template
      this.render();

      // combine render calls
      this.render({
        'myCustomFooter': { to: 'footer' },
        'myCustomAside': { to: 'aside' }
      });
    },

    after: function () {
      // this is run after our action function
    }
  });
});
</code></pre>

<p>Hooks and your action function are reactive by default. This means that if you
use a reactive data source inside of one of these functions, and that reactive
data source invalidates the computation, these functions will be run again.</p>

<h3 id="unload-hook">Unload Hook</h3>

<p>Unload hooks will be called before a RouteController is unloaded and a new
RouteController is run. This hook is useful for cleaning up Session data for
example.</p>

<pre><code class="javascript">Router.map(function () {
  this.route('postShow', {
    path: '/login',

    unload: function () {
      // This is called when you navigate to a new route
      Session.set('postId', null);
    }
  });
});
</code></pre>

<h3 id="global-router-configuration">Global Router Configuration</h3>

<p>So far we've been defining all of our route options on the routes themselves.
But sometimes it makes sense to define global options that apply to all routes.
This is most often used for the <code>layoutTemplate</code>, <code>notFoundTemplate</code>, and
<code>loadingTemplate</code> options. You can globally configure the Router like this:</p>

<pre><code class="javascript">Router.configure({
  layoutTemplate: 'layout',
  notFoundTemplate: 'notFound',
  loadingTemplate: 'loading'
});
</code></pre>

<h2 id="server-side-routing">Server Side Routing</h2>

<p>Defining routes and configuring the Router is almost identical on the server and
the client. By default, routes are created as client routes. You can specify
that a route is intended for the server by providing a <code>where</code> property to the
route like this:</p>

<pre><code class="javascript">Router.map(function () {
  this.route('serverRoute', {
    where: 'server',

    action: function () {
      // some special server side properties are available here
    }
  });
});
</code></pre>

<p>Note that <code>where</code> must be placed in <code>Router.map</code>, not on the controller.</p>

<p>Server action functions (RouteControllers) have different properties and methods
available. Namely, there is no rendering on the server yet. So the <code>render</code>
method is not available. Also, you cannot <code>waitOn</code> subscriptions or call the
<code>wait</code> method on the server. Server routes get the bare <code>request</code>, <code>response</code>,
and <code>next</code> properties of the Connect request, as well as the params object just
like in the client.</p>

<pre><code class="javascript">Router.map(function () {
  this.route('serverFile', {
    where: 'server',
    path: '/files/:filename',

    action: function () {
      var filename = this.params.filename;

      this.response.writeHead(200, {'Content-Type': 'text/html'});
      this.response.end('hello from server');
    }
  });
});
</code></pre>

<h2 id="route-controllers">Route Controllers</h2>

<p>Most of the time, you can define how you want your routes to behave by simply
providing configuration options to the route. But as your application gets
larger, you may want to separate the logic for handling a particular route into
a separate class. This is useful for putting route handling logic into separate
files, but also for utilizing features like inheritance. You can do this by
inheriting from <code>RouteController</code>. This works on both the client and the server,
but each has slightly different methods as described above.</p>

<p>Although we haven't been working with <code>RouteController</code>s directly, under the
hood they were getting created automatically for us when our routes were run.
These are called "anonymous" <code>RouteController</code>s. But we can create our own like
this:</p>

<pre><code class="javascript">PostShowController = RouteController.extend({
  /* most of the options we've been using in our routes can be used here */
});
</code></pre>

<p>How does a route know about our custom RouteController? Let's say we have a
route named "postShow." When the route is run, it will look for a global object
named "PostShowController," after the name of the route. We can change this
behavior by providing a <code>controller</code> option to the route like so:</p>

<pre><code class="javascript">Router.map(function () {

  // provide a String to evaluate later
  this.route('postShow', {
    controller: 'CustomController'
  });

  // provide the actual controller symbol if it's already defined
  this.route('postShow', {
    controller: CustomController
  });
});
</code></pre>

<p>We can define almost all of the same options on our RouteController as we have
for our routes. For example:</p>

<pre><code class="javascript">PostShowController = RouteController.extend({
  template: 'postShow',

  layoutTemplate: 'postLayout',

  before: function () {
  },

  after: function () {
  },

  waitOn: function () {
    return Meteor.subscribe('post', this.params._id);
  },

  data: function () {
    return Posts.findOne({_id: this.params._id});
  },

  action: function () {
    /* if we want to override default behavior */
  }
});
</code></pre>

<p>Note that <code>before</code> and <code>after</code> are class level methods of our new controller. We
can pass them as properties to the <code>extend</code> method for convenience. But we can
also do this:</p>

<pre><code class="javascript">PostShowController.before(function () {});
PostShowController.after(function () {});
</code></pre>

<p>(But note <code>where</code> is not available on controllers, only in <code>Router.map</code>.)</p>

<p>In Coffeescript we can use the language's native inheritance.</p>

<pre><code class="coffeescript">class @PostShowController extends RouteController
  before: -&gt;
    # do some stuff before the action is invoked

  after: -&gt;
    # do some stuff after the action is invoked

  layout: 'layout'

  template: 'myTemplate'
</code></pre>

<h2 id="examples">Examples</h2>

<h3 id="parsing-url-parameters-oauth-example">Parsing Url Parameters (OAuth Example)</h3>

<p>Iron Router will automatically parse a parameterized URL request, and separate out the parameters into an object.  However, accessing those parameters requires extending a RouteController.  Consider the following scenario:</p>

<pre><code class="`ruby"># OAuth Configuration Scenario

# OAuth requires a redirect URL as part of it's configuration.
http://localhost:3600/stripe

# the oauth authentication process will redirect users to that URL with parameterized tokens
http://localhost:3600/stripe?scope=read_only&amp;code=ac_2QGZP0nOBmb0Lxk9q3pMzaRvOi4fMU8j

# so the Router needs to parse the following line of code
?scope=read_only&amp;code=ac_2QGZP0nOBmb0Lxk9q3pMzaRvOi4fMU8j

# in order to obtain the following parameters
scope = read_only
code = ac_2QGZP0nOBmb0Lxk9q3pMzaRvOi4fMU8j
</code></pre>

<p>`</p>

<p>To parse the <code>scope</code> and <code>code</code> parameters correctly, we need to set up something like the following:</p>

<pre><code class="`js">//---------------------------------------------------------------------------------------------------------------------
// Iron Router Configuration

Session.setDefault('oauth_scope', '');
Session.setDefault('oauth_code', '');

// create the route like normal; the parameters will be automatically parsed
Router.map(function() {
    this.route('stripeRedirect', { path: '/stripe'});
});

// and extend the controller, so you can access the this.params object
StripeRedirectController = RouteController.extend({
    run: function () {
        // the code parameter has been automatically parsed and is available for use
        console.log('stripe.code: ' + this.params.code);
        Session.set('oauth_code', this.params.code);

        // as is the scope parameter
        console.log('stripe.scope: ' + this.params.scope);
        Session.set('oauth_scope', this.params.scope);

        // when all this is done, be sure to render the template specified in the router map
        this.render('stripeRedirect');
    }
});
</code></pre>

<p>`</p>

<p>Once you have access to the parameters, there are numerous ways to pass those variables throughout your app.  <code>Session.set()</code> is just one method.  You'll need to choose whether you want to use reactive <code>Session</code> variables or not.  </p></div></div></div></div></body></html>